# 객체 지향의 오해와 진실

## 01. 협력하는 객체들의 공동체
  - 객체지향적 프로그래밍은 **역할**과 **책임**을 갖고 **협력**하는 자율적인 객체들의 집합으로 시스템을 분할하는 방식이다.
    - 객체 : 시스템에서 어떤 역할과 책임을 수행하는 작은 단위
    - 메소드 : 객체들이 역할을 수행해내는 방식이다.
      - 객체가 **수신된 메시지를 처리하는 방법**을 의미한다.
      - 메소드는 객체 안에 구현되있는 프로시저, 함수를 통해서 구현된다.
    - 메시지 : 객체들 간에 주고받는 요청과 응답들을 말한다.
      - 메시지를 **보내는 객체가 송신자**
      - 메시지를 **받는 객체가 수신자**
  - **역할**이란, 객체들이 갖고 있는 책임, 임무를 의미한다.
    - 관련성 높은 책임의 집합이다.
    - 여러 객체가 동일한 역할을 수행할 수 있다.
    - 한 객체가 여러 역할을 수행할 수도 있다.
    - 역할은 대체가능성을 의미한다.
    - 객체는 역할 수행방식을 자유롭게 결정할 수 있다. (**다형성**)
  - **책임**이란, 객체들이 완수해야하는 개별적인 목표를 의미한다.
    - 적절한 책임의 선택이 중요하다.
  - **협력**이란, 요청과 응답으로 구성된 과정을 통해서 목표를 이루는 방법이다.
    - 객체는 다른 객체와의 협력을 통해 기능을 구현한다.
    - 그러므로, 객체들은 서로 협력적이어야 한다.
     - 전지전능한 객체는 자멸한다.
     - 객체는 요청에 복종하는 것이 아니라, 응답하는 것이다. 응답의 방식 또한 객체 본인이 정한다.
     - 객체는 스스로 판단하는 자율적인 존재이다.
  - 객체는 **상태**와 **행동**을 함께 지니는 **자율적인** 존재다.
    - 객체의 자율성이란, 스스로 상태를 관리하고, 그를 바탕으로 판단하고 행동할 수 있는 것을 의미한다.
    - 자율성을 갖기 위해서는 필요한 행동과 상태를 같이 지니고 있어야 한다.
    - 자율성은 객체의 **접근불가능한 내부와, 접근가능한 외부를 구분**하는 것에서 생긴다.
    - 자율성은 또한, **메시지와 메서드 처리 과정의 분리**에서도 생긴다.
  - 자율적인 객체들로 이루어진 공동체는 **유지보수가 쉽고**, **재사용이 용이한 시스템을 구축**할 수 있는 가능성을 제시한다.
  - 절차지향프로그래밍과 객체지향프로그래밍
    - 절차지향 프로그래밍
      - 프로그램의 순서와 흐름을 먼저 세우고, 필요한 자료구조와 함수들을 설계하는 방식을 사용하는 프로그래밍 기법
      - 프로시저 호출에 대한 실행코드를 컴파일 시간에 결정한다.
    - 객체지향 언어
      - 데이터 자료구조와 이를 중심으로 한 모듈들을 먼저 설계한 다음에 이들의 실행순서와 흐름을 짜는 방식을 사용하는 프로그래밍 기법
      - 메시지를 수신한 객체가 실행시간에 메서드를 선택한다.
  - 정리
    - 객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고, 객체를 이용해서 시스템을 분할하는 방식이다.
    - 자율적인 객체란, 상태와 행위를 함께 지니며 스스로 책임지는 객체를 의미한다. (ex.음료수 객체조차 본인 스스로 상태를 변경한다!)
    - 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다. 각 객체는 협력 내에서 정해진 역할을 수행하며, 역할은 관련 책임의 집합이다.
    - 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 받은 수신자는 처리를 위한 메소드를 자율적으로 선택한다.    
  
 ## 02. 이상한 나라의 객체
  - 객체란? 
    - **독립적이고, 다른 것들과 구별가능한 구체적인 사물이나, 추상적인 개념을 의미한다.**
  - 객체의 구성
    - **구별가능한 식별자와, 특정적인 행동과, 변경가능한 상태로 이루어져있다.**
    - 객체는 소프트웨어 상에서 저장된 상태와, 실행가능한 코드로 이루어진 행동으로 구현된다.
    - 행동과 상태, 식별자의 관계
      - 상태에 따라 행동의 결정되고, 행동에 따라서 상태가 결정된다.
      - 이전 상태에 따라서 행동 이후의 상태가 결정된다. (행동의 결과가 상태에 의존적이다.)
      - 행동의 순서에 따라서도 행동 이후의 상태가 달라진다.
      - 객체는 식별자를 통하여 어떤 행동과 상태변화가 일어나더라도 유일하게 식별가능하다.
  - 상태
    - **상태는 특정 시점의 객체가 가지고 있는 정보의 집합이다. 객체의 구조적 특징을 표현한다.**
    - 상태의 구성
      - 상태는 객체에 존재하는 정적인 프로퍼티와, 동적인 프로퍼티의 값으로 이루어져 있다.
      - 프로퍼티는 단순한 값인 속성(attribute)과, 다른 객체를 참조하는 링크(link)로 구분된다.
    - 상태의 특징
      - 상태는 외부에서 가시적이지 않다. 그러므로 객체는 외부객체의 상태에 직접적으로 관여할 수 없다. 
  - 행동
    - **행동은 내부 상태를 변경하거나, 외부의 메시지에 응답하거나, 외부로 메시지를 전달하는 활동이다.**
    - 상태와 행동
      - 행동은 상태를 변화시킨다.
      - 또한 행동은 이전 상태에 영향을 받는다.
    - 협력과 행동
      - 객체들간의 협력은, 행동을 통한 유일한 협력방식인 메시지의 교환으로 이루어진다.
      - 메시지 교환시, 객체 자체의 상태변경이 일어난다.
      - 메시지 교환시, 수신객체의 상태변경을 유도할 수 있다.
    - 행동의 특징
      - 행동은 가시적이다. 그러므로 객체는 행동을 통하여 다른 객체와 협력할 수 있게된다.
  - 캡슐화
    - **객체의 상태와 행동이 하나의 묶음으로 묶이는 것을 의미한다.**
    - **객체가 노출하는 멤버변수와 멤버함수에만 접근할 수 있게 하고, 상태는 캡슐안에 감춰두는 것을 의미한다.**
    - 객체간의 메시지 전달이 일어난다는 것만 알 수 있을 뿐, 행동을 통해 유발된 객체의 상태변화의 결과는 알 수 없다. 
    - 캡슐화의 이점
      - 객체의 자율성을 높인다.
      - 협력을 유연하고 단순하게 만든다.
  - 식별자
    - **식별자는 서로 다른 객체를 구별가능하게 해주는 고유한 프로퍼티를 의미한다.**
    - 객체와 값의 차이점
      - 객체는 고유한 식별자를 지니지만, 값은 식별자를 지니지 않는다.
      - 값은 상태변화가 없다. 값의 구분은 상태를 바탕으로 하는 동등성 검사를 통해 이뤄진다.
      - **상태를 바탕으로 값이 같은 값인지 판단하는 것을 '동등성(equality)'이라고 한다.**
      - 객체는 상태변화가 있다. 객체의 구분은 식별자를 바탕으로 하는 동일성 검사를 통해 이뤄진다.
      - **식별자를 바탕으로 객체가 같은 객체인지 판단하는 것을 '동일성(identical)'이라고 한다.**
  - 쿼리(query)와 명령(command)
    - 쿼리(query)는 객체의 상태를 조회하는 것이다.
    - 명령(command)는 객체의 상태를 변경하는 작업이다.
    - 명령과 쿼리 모두, 객체가 외부에 제공하는 행동이다.
  - 협력을 고려한 객체설계
    - **객체설계시, 행동을 먼저 고려하고 상태를 나중에 결정해야 한다. 협력의 문맥에 맞는 적절한 객체를 만들어야 하기 때문이다.**
    - **행동이 상태를 결정한다.**
    - 객체지향의 문맥은 객체들간의 협력에 방점에 찍혀있기 때문에, 상태를 먼저 고려한다면, 객체를 고립시킬 수 있다.
    - 상태 고려에 초점을 둔다면 재사용성이 떨어질 수 있다.
    - 상태 고려에 초점을 둔다면 캡슐화의 이점을 살리지 못할 수도 있다.
  - 단순한 현실의 모방이 아닌 객체설계
    - 현실세계의 객체를 핵심만 추려서 모방하여 설계하는 것이 객체지향적 설계가 아니다.
    - **현실세계를 은유하여, 새로운 객체지향세계를 창조하는 것이 객체지향설계의 본질이고, 이 과정에서 의인화의 과정이 수반된다!**
    - **객체는 '의인화'된다.**
      - **현실에서는 수동적이던 객체도, 프로그램 상에서는 본인의 상태를 판단하여 그에 맞는 행동을 하는 능동성을 지니게 된다.**
      - 예) 총 class : 총알의 수(상태)를 판단하여 행동한다, 물병 class : 남은 물의 양(상태)을 판단하여 행동한다.
    - **코드상의 객체는 현실 세계의 객체를 '은유'한다.**
      - **객체지향세계의 객체가 현실세계의 객체를 은유함으로써, 우리는 객체의 의미를 더 잘 이해할 수 있게 된다.**
      - 은유를 통해서 현실세계의 객체와 표현적 차이를 줄이는 것은 코드의 이해도를 높이고, 유지보수가 용이한 프로그램을 만들게 돕는다.
    
## 03. 추상화와 타입
  - **추상화**
    - **추상화의 본질은, 복잡성을 이해하기 쉬운것으로 만들어 극복함에 있다.**
    - 추상화에 이르는 2가지 방법이 존재한다. : 분류 / 일반화 -> 특수화
      - **공통적인 개념(행동)을 바탕으로, 객체를 분류한다. 이때 분류된 객체를 개념의 인스턴스라 한다.**
      - **목적에 부합하는 중요한 부분 외의 불필요한 세부사항을 제거하여 문제를 일반화 시키고, 거기서 발전시키며 특수화 시킨다.**
      
  - **추상화 > 개념**
    - 개념
      - 개념은 객체들을 묶어주는 의미적 정의이다.
    - 개념의 3가지 요소
      - symbol (상징) : 개념의 이름.
      - intenstion (내연) : 개념의 완전한 정의.
      - extension (외연) : 개념에 속한 인스턴스 집합.
      - 개념의 3가지 요소는 객체 분류 방식에 대해서 지침을 제공한다. 
    - **객체지향설계와 개념의 의미**
      - **객체지향적 설계에서는 추상화를 위한 개념바탕의 객체 분류를, 복잡성 극복의 가장 기본적 인지수단으로 사용한다.**
      - 쉽게 말해서, 개념은 복잡한 상태를 단순화하기 위한 추상화도구이다.
  
  - **추상화 > 분류**
    - 분류
      - 분류는 객체에 특정 개념을 적용할지 말지를 정하는 과정이다.
    - **객체지향설계와 분류의 의미**
      - 분류가 잘 된 프로그램은 유지보수가 용이하지만, 그렇지 못한 프로그램은 불리하다.
      - 수많은 객체의 위치를 쉽게 찾을 수 있는 개념지도를 개발자에게 제공한다.
      
  - **타입(type)**
    - **프로그래밍에서 개념을 타입(type)이라고 한다.**
      - 프로그램 내의 데이터들을 묶어주는 의미적 정의이다. 보통 연산수단에 따라서 데이터들이 묶인다.
    - **데이터 타입(data type)**
      - 데이터를 가능한 연산종류에 따라서 나눈 것이 데이터 타입이다.
      - 특정 데이터 타입의 데이터가 메모리에 어떻게 저장되는지 알 수 없어도 우리는 데이터 타입 연산에 지장받지 않는다.
 
  - **객체와 타입**
    - **수행가능한 행동종류에 따라서 객체를 타입으로 분류할 수 있다. 행동이 기준이다!** : 다형성 발생
    - **특정 객체의 내부적 표현이 어떤 식으로 이루어지는지 알 수 없어도 객체의 행동에 지장을 주지 않는다.** : 캡슐화 발생
    - **객체를 위한 타입을 정의하는 이유**
      - '변화 속의 모든 순간'에서 벗어나서, '변한다는 사실'에만 집중하게 해준다. = 고정된 틀을 만들어주는 느낌이다.
      - 시간에 따라 바뀌는 동적인 객체의 모습에서, 시간을 배제한 객체의 정적인 모습으로 추상화해준다.
      - 결국 타입 또한, 시간을 배제해주는 추상화이다. 복잡성을 단순화시켜주는 것이다.
 
  - **다형성**
    - **언어의 요소들이 다양한 자료형에 속하는 것이 허가되는 성질이다. (여러가지 형태를 갖을 수 있는 능력을 말한다.)**
    - **다형성은 같은 요청에 서로 다른 결과를 도출할 수 있게 한다.**
    - 1.객체는 행동에 따라서 그 타입이 분류된다. 데이터는 상관이 없다. -> 2.같은 타입 속의 객체라 할지라도 서로 다른 데이터를 갖을 수 있다.
    - -> 3. 다른 데이터를 갖고 있는 같은 타입의 객체들이 같은 메시지를 처리하는 방법과 결과는 다르다.
 
  - 책임-주도 설계(responsibility-driven design) / 데이터-주도 설계(data-driven design)
    - **책임-주도 설계(responsibility-driven design)**
      - 제공되어야하는 행동 방식을 먼저 설정하고, 그에 따르는 데이터를 나중에 결정하는 설계방식. 
    - **데이터-주도 설계(data-driven design)** 
      - 필요한 데이터를 먼저 설정하고, 그 데이터에 따르는 행동방식을 나중에 결정하는 설계방식.
      
  - 타입 모델(type-model) / 동적 모델(dynamic-model)
    - 객체지향프로그래밍에서는 프로그램의 설계를 두가지 관점에서 파악한다. : 정적관점, 동적관점
    - **타입 모델(type-model)**
      - 시간의 흐름 반영 X
      - 객체가 속한 타입의 정적인 상태를 파악하는 것, 시간의 변화에 관계없이 모든 상태와 행동을 독립적으로 파악하는 것을 타입모델이라고 한다.
      - **정적 모델(static-model)**이라고도 한다.
    - **동적 모델(dynamic-model)**
      - 시간의 흐름 반영 O
      - 객체가 특정 시점에 어떤 상태인지를 보여주는 것을 **객체 스냅샷(snapshot)**이라고 한다.
      - UML(객체지향모델링을 위한 표준 언어)에서는 스냅샷을 **객체 다이어그램(object diagram)**이라고도 한다.
      - 객체가 시간에 따라 어떻게 변해가는지를 파악하는 것을 동적모델이라고 한다. 
    - 객체지향프로그래밍에서는 이 두가지 모델링을 같이 잘 사용해야 한다.
 
  - 일반화 / 특수화 관계
    - **객체의 행동을 바탕으로** 더 구체적인 자신만의 행동을 하면 특수화된 행동이라고 한다.
      - 특수한 타입은 일반적인 타입의 행동을 포함하여 더 많은 행동을 해야한다.
      - 유도 객체는 더 **구체적인 자신만의 행동**을 해야한다.
    - **객체의 행동을 바탕으로** 더 일반적인 모두 하는 행동을 하면 일반화된 행동이라고 한다.
      - 일반적인 타입은 특수한 타입에 비해 더 적은 행동을 한다.
      - 기초 객체는 더 **일반적인 모두 하는 행동**을 해야한다.
    
  - 타입을 구현하는 방식중의 하나가 class인것이지, class가 전부인 것이 아니다.  
    
  - **객체를 분류하는 기준 : 타입 / 타입 분류의 기준 : 행동**
    
    
    
    
    
 
 
  
